This document [available in English](README.md).

## Быстрый старт

Две стороны могут обмениваться зашифрованными сообщениями, предварительно договорившись использовать пароль (password). Вы можете использовать пример реализации следующим образом:

```rust
use rust_aes256::AES256;

fn main() {
    let password: &str = "secret";
    let original: &str = "Original string";

    let aes256: AES256 = AES256::new(password.as_bytes());
    let encrypted: String = aes256.encrypt(&original).expect("Unable to encrypt original message");
    println!("Encrypted: {}", encrypted);
    
    let decrypted: String = aes256.decrypt(&encrypted).expect("Unable to decrypt encrypted message");
    println!("Decrypted: {}", decrypted);
}
```

По сети вы сможете отправлять данные примерно такого формата:

```json
{
  "data": "yRN4j3X9ReBocpR6vWrtG96ASY1EXVuptZ/TxrIBvk3zUP3wIMEBOjKnhQfQGVDqn5v5mWjP7x605k82rr5rCg=="
}
```

Эта библиотека не опубликована на crates.io. Так что перед тем, как начать, вы должны:

1. Склонировать репозиторий, прогнать тесты и собрать исходный код
```sh
git clone
cargo test
cargo build --release
```

2. Добавить зависимость в ваш `Cargo.toml`
```toml
[dependencies]
rust_aes256 = { path = "path/to/rust_aes256" }
```

## Детали

AES – симметричный алгоритм блочного шифрования. Это способ шифрования данных, при котором один и тот же ключ используется и для кодирования, и для восстановления информации. Алгоритм AES представляет собой итеративный блочный шифр с симметричным ключом, который поддерживает криптографические ключи (секретные ключи) длиной 128, 192 и 256 бит для шифрования и дешифрования данных блоками по 128 бит. Если данные, подлежащие шифрованию, не соответствуют требованию к размеру блока в 128 бит, они должны быть дополнены. Последний блок будет дополнен до 128 бит.

Варианты AES:

 * ECB (Electronic Code Book) – открытый текст разбивается на блоки размером 128 бит. Затем каждый блок шифруется одним и тем же ключом и алгоритмом. Это означает, что идентичные блоки открытого текста приведут к идентичным блокам зашифрованного текста.
 * CBC (Cipher Block Chaining) – режим CBC решает проблему идентичных блоков открытого текста в ECB. Он вводит вектор инициализации (IV) для первого блока и выполняет XOR для предыдущего блока зашифрованного текста с текущим блоком открытого текста перед шифрованием. Режим CBC обеспечивает более высокий уровень безопасности, чем ECB, и широко используется в протоколах защищенной связи, таких как SSL/TLS, IPSec и VPN.

В этой библиотеке используется AES-256 CBC.

Термины:

 * Сообщение – это набор данных, которыми мы обмениваемся по сети
 * Пароль – это "секретный ключ", которым мы обменяемся один раз. Он представляет собой строку произвольной длины
 * Секретный ключ – это бинарный ключ AES-256 длиной 256 бит (32 байта), представляющий собой хэш от пароля
 * Соль - это случайные 8 байт, которое добавляется в конец пароля при формировании секретного ключа. Передаётся открыто в начале сообщения
 * Вектор инициализации - это случайные 16 байт, которые потребуются для реализации AES-256-CBC. Передаётся открыто в начале сообщения
 * Зашифрованные данные - это данные, зашифрованные алгоритмом AES-256-CBC. Одна из частей сообщения

## Сообщение

По сети будут передаваться сообщения следующего формата:

```
                   BASE64
+----------+--------------+-----------------+
|   Salt   | Init. vector |     Payload     |
|  8 byte  |   16 byte    |    Any length   |
+----------+--------------+-----------------+
```

Сообщение представляет собой набор байт, закодированных в base64. Сообщение имеет следующий формат:

 * Соль - первые 8 байт (salt)
 * Вектор инициализации - следующие 16 байт (iv, Initialization vector)
 * Зашифрованные алгоритмом AES-256-CBC данные (payload)

## Соль

Как указано выше, алгоритм AES-256 работает с ключами длиной 256 бит, но пароль (секретный ключ в виде строки, которым мы обменяемся) может быть произвольной длины. Для того, чтобы из текстового пароля произвольной длины сделать двоичный ключ фиксированной длины, который нужен для шифрующего алгоритма, используется хеш-функция.

```
password = "секретный ключ в виде строки, которым мы обменяемся"
aes256key = hash(password)
```

Что произойдет, если злоумышленник каким-то образом получит ключ (aes256key)? Хотя пароль (password) он не узнает (хеш-функция по определению является односторонней), все файлы, зашифрованные данным паролем, окажутся доступны, т.к. они зашифрованы тем же самым ключом (aes256key), и неважно из какого пароля этот ключ получен. Для того, чтобы избежать такой ситуации, используется чуть более сложная система генерации ключа:

```
password = "секретный ключ в виде строки, которым мы обменяемся"
aes256key = hash(password + salt)
```

Здесь salt - соль, случайная строка. Соль не является секретом, и обычно передается открыто вместе с зашифрованным сообщением. Допустим, мы зашифровали два файла одним паролем (password). Ключи для них будут сгенерированы следующим образом:

```
password = "секретный ключ в виде строки, которым мы обменяемся"
aes256key1 = hash(password + salt1)
aes256key2 = hash(password + salt2)
```

Если злоумышленник получил aes256key1, он не может получить из него пароль (как и в простой схеме). Также при компрометации одного ключа (aes256key1 или aes256key2), сам пароль (password), и другие зашифрованные файлы никак не пострадают.

Использование обычного целого числа, записанного как строка, в качестве соли даст 4 миллиарда вариаций, а 64-битового числа должно быть в любом случае достаточно.

## Вектор инициализации

Блочный шифр шифрует строго один блок. В нашем случае (AES-256) 16 байт. Исходный поток дополняется (padded) до размера, кратного размеру блока. Затем поток шифруется, блок за блоком. Эта схема называется ECB (Electronic Code Book). Проблема с ней в том, что одинаковые входные данные дают одинаковые зашифрованные блоки. Из анализа одинаковых блоков можно делать какие-то выводы о содержании файла.

Для борьбы с этим используется метод связывания блоков (block chaining). В простейшем случае это просто XOR с предыдущим блоком. Для простоты можно сказать, что методы связывания основаны на том, что текущий блок как-то замешивается с предыдущим. Поэтому естественным образом возникает вопрос - с чем замешивать самый первый блок? С искусственно сгенерированным "нулевым" блоком, который называется "инициализационным вектором".

Как и соль, инициализационный вектор не является секретом. В нашем случае мы будем передавать его в начале зашифрованного сообщения.

## Процесс шифрования

Общая схема процесса шифрования выглядит так:

```
+------------+    +--------+
|   Пароль   |    |  Соль  |
| (password) |    | (salt) |
+------------+    +--------+
          |           |
          ▼           ▼
        +----------------+   +------------------------+
        |   Секретный    |   |                        |
        |  ключ AES-256  |   |         Вектор         |
        | длиной 256 бит |   |       инициализации    | 
        |  (secret key)  |   | (initialization vector)| 
        +----------------+   +------------------------+
                      |         |
                      ▼         ▼
                     +-----------+
     Данные    ----- |    Шифр   | ---------> Зашифрованные
для шифрования       |  (Cipher) |               данные
                     +-----------+              (payload)
```

Для того, чтобы зашифровать данные, нам понадобятся:

 * `data` - Непосредственно данные для шифрования
 * `password` - Пароль для шифрования (ключ, которым мы обменяемся один раз, в виде строки произвольной длины)
 * `salt` - Случайно сгенерированная соль (массив байт размером 8)
 * `initialization vector` - Случайно сгенерированный вектор инициализации (массив байт размером 16)

Алгоритм работы шифрования:

1. Сгенерировать соль
2. Сгенерировать вектор инициализации
3. Сформировать секретный ключ AES-256 (бинарный ключ размером 256 бит) на основе пароля (password) и соли (salt)
4. Сформировать шифр (cipher) на основе секретного ключа (secret key) и вектора инициализации (initialization vector)
5. Применить шифр (cipher) к данным для шифрования и получить зашифрованные данные (payload)
6. Сформировать сообщение message в виде массива байт
```
+----------+--------------+-----------------+
|   Salt   | Init. vector |     Payload     |
|  8 byte  |   16 byte    |    Any length   |
+----------+--------------+-----------------+
```
7. Преобразовать сообщение message в формат base64.

## Процесс расшифровки

Процесс дешифрования похож на процесс шифрования:

```
+------------+    +--------+
|   Пароль   |    |  Соль  |
| (password) |    | (salt) |
+------------+    +--------+
          |           |
          ▼           ▼
        +----------------+   +------------------------+
        |   Секретный    |   |                        |
        |  ключ AES-256  |   |         Вектор         |
        | длиной 256 бит |   |       инициализации    | 
        |  (secret key)  |   | (initialization vector)| 
        +----------------+   +------------------------+
                      |         |
                      ▼         ▼
                     +-----------+
Зашифрованные  ----- |    Шифр   | ---------> Расшифрованные
   данные            |  (Cipher) |               данные
  (payload)          +-----------+              
```

Отличие в том, что больше нет необходимости генерировать пароль и соль. Теперь мы читаем их из начала переданного сообщения. Также теперь мы используем шифр в обратную сторону -- для дешифрования.

Полный алгоритм дешифрации:

1. Получить сообщение, закодированное в base64

```
+-------------------------------------------+
|                BASE64                     |
+----------+--------------+-----------------+
|   Salt   | Init. vector |     Payload     |
|  8 byte  |   16 byte    |    Any length   |
+----------+--------------+-----------------+
```

2. Декодировать сообщение и получить набор байт
```
+----------+--------------+-----------------+
|   Salt   | Init. vector |     Payload     |
|  8 byte  |   16 byte    |    Any length   |
+----------+--------------+-----------------+
```

3. Сохранить соль (Salt), первые 8 байт сообщения, в массив байт
4. Сохранить вектор инициалзации (Init. vector), следующие 16 байт сообщения, в массив байт
5. Сохранить зашифрованные данные (Payload), оставшуюся часть сообщения, в массив байт
6. Сформировать секретный ключ AES-256 (бинарный ключ размером 256 бит) на основе пароля (password) и соли (salt)
7. Сформировать шифр (cipher) на основе секретного ключа (secret key) и вектора инициализации (initialization vector)
8. Применить шифр (cipher) к зашифрованным данным (payload) для расшифровки и получить данные
